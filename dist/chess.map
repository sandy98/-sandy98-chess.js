{"version":3,"sources":["game.ts","chess.ts"],"names":[],"mappings":"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","file":"chess.map","sourceRoot":"../src/lib","sourcesContent":["\n  export interface IFenObj {\n    pos: string\n    fenPos: string\n    turn: string\n    castling: string\n    enPassant: string\n    halfMoveClock: number\n    fullMoveNumber: number\n  }\n  \n  export interface IResults {\n    white: string\n    black: string\n    draw: string\n    unterminated: string\n  }\n\n  export interface ISevenTags {\n    Event: string\n    Site: string\n    Date: string\n    Round: string\n    White: string\n    Black: string\n    Result: string\n  }\n\n  export interface IMoveInfo {\n    turn: string  \n    from: number\n    to: number\n    figureFrom: string\n    figureTo: string\n    promotion: string\n    capture: boolean\n    infoOrigin?: string\n    check?: boolean\n    checkmate?: boolean\n    stalemate?: boolean\n    castling: boolean\n    san: string\n    fullMoveNumber: number\n    enPassant: boolean\n  }\n\n  export interface IGame {\n    tags: ISevenTags\n    fens: string[]\n    sans: IMoveInfo[]\n    ascii(flipBoard: boolean, n: number): string\n    clear(): void\n    fen(index: number): string\n    game_over(): boolean\n    get(square: any, index: number): string\n    in_check(index: number): boolean\n    in_checkmate(index: number): boolean\n    in_draw(index: number): boolean\n    in_stalemate(index: number): boolean\n    in_threefold_repetition(index: number): boolean\n    move(...args: any[]): boolean\n    moves(options: object): string[]\n    pgn(): string\n    header(...args: string[]): ISevenTags\n    insufficient_material(n: number): boolean\n    load(fen: string): boolean\n    load_pgn(pgn: string): boolean  \n    put(figure: string, square: any, index: number): boolean\n    remove(square: any, index: number): boolean\n\n    square_color(square: any): string\n    turn(index: number): string\n    undo(): boolean\n    validate_fen(fen: string): boolean    \n  }\n\n  export class Game implements IGame {\n    static outOfBounds(...args: number[]): boolean {\n      for (let n: number = 0; n < args.length; n++) {\n        if (args[n] < 0 || args[n] > 63) return true\n      }\n      return false\n    }\n\n    static capitalize(word: string): string {\n      return `${word[0].toUpperCase()}${word.split('').slice(1).join('').toLowerCase()}`\n    }\n\n    static PgnDate(dt: Date = new Date()): string {\n      let y = dt.getFullYear()\n      let m = (dt.getMonth() + 1).toString().replace(/^(\\d)$/, '0$1')\n      let d = (dt.getDate()).toString().replace(/^(\\d)$/, '0$1')\n      return `${y}.${m}.${d}`\n    }\n\n    static row(sq: number|string): number {\n      if (typeof sq === 'string') sq = Game.san2sq(sq)\n      return Math.floor(sq / 8)\n    }\n    static col(sq: number|string): number {\n      if (typeof sq === 'string') sq = Game.san2sq(sq)\n      return sq % 8\n    }\n\n    static col2string(r: number): string {\n      return r < 8 && r >= 0 ? String.fromCharCode(r + 97) : ''\n    }\n\n    static string2col(c: string): number {\n      return !!c.match(/^[a-h]$/) ? c.charCodeAt(0) - 97 : -1\n    }\n\n    static row2string(r: number): string {\n      return r < 8 && r >= 0 ? (r + 1).toString(10) : ''\n    }\n\n    static string2row(c: string): number {\n      return !!c.match(/^[1-8]$/) ? c.charCodeAt(0) - 49 : -1\n    }\n\n    static rowcol2sq(row: number, col: number): number {\n      if (row < 0 || row > 7 || col < 0 || col > 7) return -1\n      return row * 8 + col\n    }\n\n    static isEven(sq: string|number): boolean {\n      if (typeof sq === 'string') sq = Game.san2sq(sq)\n      return sq % 2 === 0\n    }\n    static isOdd(sq: string|number): boolean {\n      if (typeof sq === 'string') sq = Game.san2sq(sq)\n      return !Game.isEven(sq)\n    }\n    static isLight(sq: string|number): boolean {\n      if (typeof sq === 'string') sq = Game.san2sq(sq)\n      const orec = Game.isOdd(Game.row(sq)) && Game.isEven(Game.col(sq))\n      const eroc = Game.isEven(Game.row(sq)) && Game.isOdd(Game.col(sq))\n      return orec || eroc\n    }\n    static isDark(sq: string|number): boolean {\n      return !Game.isLight(sq)\n    }\n\n    static xor56(pos: string): string {\n      let splitted: string[] = pos.split('')\n      return splitted.map((_, i) => splitted[i ^ 56]).join('')\n    }\n\n    static compressFenPos(pos: string = Game.fen2obj().pos): string {\n      return Game.xor56(pos).match(/\\w{8}/g).join('/').replace(/0+/g, z => z.length.toString())\n    }\n\n    static expandFenPos(fenPos: string = Game.fen2obj().fenPos): string {\n      return Game.xor56(fenPos.split('/').join('').replace(/\\d/g, d => '0'.repeat(parseInt(d))))\n    }\n\n    static deprecatedCompressFenPos(pos: string = Game.fen2obj().pos): string {\n      let splitted = pos.split('')\n      let inverted = splitted.map((_, i) => splitted[i ^ 56]).join('')\n      return inverted.replace(/(\\w{8})(?=\\S)/g, \"$1/\")\n      .replace(/(0+)/g, zeros => zeros.length.toString())\n    }\n  \n    static deprecatedExpandFenPos(fenPos: string = Game.fen2obj().fenPos): string {\n      let expanded = fenPos.replace(/\\//g, '')\n      .replace(/\\d/g, (i) => '0'.repeat(parseInt(i)))\n      let splitted = expanded.split('')\n      return splitted.map((_, i) => splitted[i ^ 56]).join('')\n    }\n  \n    static fen2obj(fen: string = Game.defaultFen): IFenObj {\n      let [fenPos, turn, castling, enPassant, shalfMoveClock, sfullMoveNumber] = fen.split(/\\s+/)\n      let pos = Game.expandFenPos(fenPos)\n      let halfMoveClock: number  = parseInt(shalfMoveClock)\n      let fullMoveNumber: number = parseInt(sfullMoveNumber)\n      return {pos, fenPos, turn, castling, enPassant, halfMoveClock, fullMoveNumber}\n    }\n  \n    static obj2fen(fenObj: IFenObj): string {\n      let {pos, fenPos, turn, castling, enPassant, halfMoveClock, fullMoveNumber} = fenObj\n      if (typeof fenPos === 'undefined') {\n        fenPos = Game.compressFenPos(pos)\n      }\n      return [fenPos, turn, castling, enPassant, halfMoveClock, fullMoveNumber].join(' ')\n    }\n  \n    static isWhiteFigure(figure: string): boolean {\n        return 'PNBRQK'.indexOf(figure) !== -1\n    }\n\n    static isBlackFigure(figure: string): boolean {\n        return 'pnbrqk'.indexOf(figure) !== -1\n    }\n\n    static isFriend(fig1: string, fig2: string): boolean {\n        return (Game.isWhiteFigure(fig1) && Game.isWhiteFigure(fig2))\n          || (Game.isBlackFigure(fig1) && Game.isBlackFigure(fig2))\n    }\n\n    static isFoe(fig1: string, fig2: string): boolean {\n        return (Game.isWhiteFigure(fig1) && Game.isBlackFigure(fig2))\n          || (Game.isBlackFigure(fig1) && Game.isWhiteFigure(fig2))\n    }\n\n    static san2sq(san: string): number {\n        if (!san.match(/^[a-h][1-8]$/)) return -1\n        return san.charCodeAt(0) - 97 + (san.charCodeAt(1) - 49) * 8\n    }\n\n    static sq2san(sq: number): string {\n        if (sq < 0 || sq > 63) return '-'\n        return `${String.fromCharCode((sq % 8) + 97)}${Math.floor(sq / 8) + 1}`\n    }\n\n    static isEqualPos(fen1: string, fen2: string): boolean {\n      let [fen_obj1, fen_obj2] = [Game.fen2obj(fen1), Game.fen2obj(fen2)]\n      return fen_obj1.fenPos === fen_obj2.fenPos\n        && fen_obj1.turn === fen_obj2.turn\n        && fen_obj1.castling === fen_obj2.castling\n        && fen_obj1.enPassant === fen_obj2.enPassant\n    }\n\n    static boardArray(): number[] {\n      const arr = new Array(64)\n      arr.fill(0)\n      return arr.map((_, i) => i)\n    }g\n\n    static countFigures(figure: string, fen: string): number {\n      const pos: string[] = Game.fen2obj(fen).pos.split('')\n      return pos.filter(f => f === figure).length\n    }\n\n    static figuresArray(figure: string, fen: string): number[] {\n      const pos: string = Game.fen2obj(fen).pos\n      return Game.boardArray().filter(i => pos[i] === figure)\n    }\n\n    static figuresColors(figure: string, fen: string): string[] {\n      let figsArr: number[] = Game.figuresArray(figure, fen)\n      return figsArr.map(i => Game.isLight(i) ? 'light': 'dark')\n    }\n\n    static results: IResults = {\n      white: '1-0',\n      black: '0-1',\n      draw: '1/2-1/2',\n      unterminated: '*'\n    }\n    static defaultFen: string = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\n    static emptyFen: string = '8/8/8/8/8/8/8/8 w - - 0 1'\n  \n    static sicilianFen: string = 'rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 1'\n    static indiareyFen: string = 'r1bq1rk1/pppnn1bp/3p4/3Pp1p1/P1P1Pp2/2N2P2/1P2BBPP/R2QNRK1 b - a3 0 13'\n    static yugoslavFen: string = 'r1bq1rk1/pp2ppbp/2np1np1/8/3NP3/2N1BP2/PPPQ2PP/R3KB1R w KQ - 3 9'\n    static berlinFen: string = 'r1bk1b1r/ppp2ppp/2p5/4Pn2/8/5N2/PPP2PPP/RNB2RK1 w - - 0 9'\n\n    static sanRegExp = /(?:(^0-0-0|^O-O-O)|(^0-0|^O-O)|(?:^([a-h])(?:([1-8])|(?:x([a-h][1-8])))(?:=?([NBRQ]))?)|(?:^([NBRQK])([a-h])?([1-8])?(x)?([a-h][1-8])))(?:(\\+)|(#)|(\\+\\+))?$/\n  \n\n////////////////////////////////////////////////////////////\n\n    fens: string[] = []\n    sans: IMoveInfo[] = []\n    tags: ISevenTags = <ISevenTags>{\n      Event: 'Internet Game',\n      Site: 'Internet',\n      Date: Game.PgnDate(),\n      Round: '?',\n      White: 'White Player',\n      Black: 'Black Player',\n      Result: Game.results.unterminated\n    }\n\n    constructor(fen: string = Game.defaultFen) {\n      this.reset(fen)\n    }\n  \n    reset(fen: string = Game.defaultFen) {\n      if (!this.validate_fen(fen)) {\n        throw new Error('Invalid FEN')\n      }\n      this.fens = [fen]\n      this.sans = [<IMoveInfo>{}]\n      this.tags.Result = Game.results.unterminated\n    }\n  \n    getMaxPos() {return this.fens.length - 1}\n\n    _getWhat(n: number = this.getMaxPos(), what: string = 'pos'): string {\n      n = n < 0 ? 0 : n >= this.fens.length ? this.getMaxPos() : n\n      return Game.fen2obj(this.fens[n])[what]\n    }\n  \n    getPos(n: number = this.getMaxPos()): string {\n      return this._getWhat(n, 'pos')\n    }\n  \n    getFenPos(n: number = this.getMaxPos()): string {\n      return this._getWhat(n, 'fenPos')\n    }\n  \n    getTurn(n: number = this.getMaxPos()): string {\n      return this._getWhat(n, 'turn')\n    }\n  \n    getCastling(n: number = this.getMaxPos()): string {\n      return this._getWhat(n, 'castling')\n    }\n  \n    getEnPassant(n: number = this.getMaxPos()): string {\n      return this._getWhat(n, 'enPassant')\n    }\n  \n    getHalfMoveClock(n: number = this.getMaxPos()): number {\n      return parseInt(this._getWhat(n, 'halfMoveClock'))\n    }\n  \n    getFullMoveNumber(n: number = this.getMaxPos()): number {\n      return parseInt(this._getWhat(n, 'fullMoveNumber'))\n    }\n\n    isShortCastling(from: number, to: number, figure: string): boolean {\n        return (from === 4 && to === 6 && figure === 'K')\n          || (from === 60 && to === 62 && figure === 'k')\n    } \n\n    isLongCastling(from: number, to: number, figure: string): boolean {\n        return (from === 4 && to === 2 && figure === 'K')\n          || (from === 60 && to === 58 && figure === 'k')\n    } \n\n    isEnPassant(from: number, to: number, npos: number = this.getMaxPos()): boolean {\n        let pos: string = this.getPos(npos)\n        return Game.col(from) !== Game.col(to) \n          && !!pos[from].match(/[Pp]/) \n          && pos[to] === '0'\n    }\n\n    isTwoSteps(from: number, to: number, npos: number = this.getMaxPos()): boolean {\n        let pos: string = this.getPos(npos)\n        return Math.abs(Game.row(from) - Game.row(to)) === 2\n          && !!pos[from].match(/[Pp]/)\n    }\n\n    isPromoting(from: number, to: number, npos: number = this.getMaxPos()): boolean {\n        let pos: string = this.getPos(npos)\n        return (pos[from] == 'P' && Game.row(to) === 7) \n          || (pos[from] == 'p' && Game.row(to) === 0)\n    }\n\n    moveInfo2san(info: IMoveInfo): string {\n        \n        if (this.isShortCastling(info.from, info.to, info.figureFrom)) return 'O-O'\n        if (this.isLongCastling(info.from, info.to, info.figureFrom)) return 'O-O-O'\n        //console.log(`In moveInfo2san, figureFrom is: ${info.figureFrom}`)\n        let figure: string = !info.figureFrom.match(/[Pp]/)\n          ? info.figureFrom.toUpperCase()\n          : info.capture\n          ? Game.sq2san(info.from)[0]\n          : ''\n\n        let infoOrigin: string = info.infoOrigin ? info.infoOrigin : ''\n        let capture: string = info.capture ? 'x' : '' \n        let dest: string = Game.sq2san(info.to)\n        let promotion: string = info.promotion ? `=${info.promotion.toUpperCase()}` : ''\n        let checkInfo: string = info.checkmate\n          ? '#'\n          : info.check\n          ? '+'\n          : '' \n\n        return `${figure}${infoOrigin}${capture}${dest}${promotion}${checkInfo}`\n    }\n\n    san2MoveInfo(san: string, fen: string = this.fen()): IMoveInfo {\n      //Must override\n      if (!fen.length) return <IMoveInfo>null\n      if (!san.length) return <IMoveInfo>null\n      return <IMoveInfo>null\n    }\n\n    canMove(moveInfo: IMoveInfo, n: number = this.getMaxPos()): boolean {\n      //Must override\n      if (n < 0 || n > this.getMaxPos()) return false\n      let { figureFrom, figureTo, turn } = moveInfo\n\n      if (\"pnbrqkPNBRQK\".indexOf(figureFrom) === -1) return false\n      if (Game.isFriend(figureFrom, figureTo)) return false\n      if ((Game.isWhiteFigure(figureFrom) && turn === 'b')\n        || (Game.isBlackFigure(figureFrom) && turn === 'w')) return false\n      \n      return true\n    }\n\n    pgnHeaders(): string {\n      let arr = []\n      for (let t in this.tags) {\n        arr = [...arr, `[${t} \"${this.tags[t]}\"]`]\n      }\n      return arr.join('\\n')\n    }\n\n    pgnMoves(): string {\n        let resp: string = this.history({verbose: true}).map(mi => {\n            let info: IMoveInfo = <IMoveInfo>mi\n            let prefix: string = info.turn === 'w' ? `${info.fullMoveNumber}. ` : ''\n            let ep: string = info.enPassant ? ' e.p.' : ''\n            return `${prefix}${info.san}${ep}`\n        })\n        .join('  ')\n        return resp\n    }\n\n// Beginning of public interface methods\n\n    ascii(flipBoard: boolean = false, n: number = this.getMaxPos()): string {\n      let dottedPos = this.getPos(n).replace(/0/g, '.')\n      let header = '   +------------------------+'\n      let blank =  ' '.repeat(header.length)\n      let footer= flipBoard ? '     h  g  f  e  d  c  b  a' : '     a  b  c  d  e  f  g  h'\n      let rows = []\n      for (let y = 0; y < 8; y++) {\n          let r = flipBoard ? ` ${y + 1} |` : ` ${8 - y} |`\n          for (let x = 0; x < 8; x++) {\n              r += ` ${dottedPos[(y * 8 + x) ^ (flipBoard ? 7 : 56)]} `\n          }\n          r += '|'\n          rows.push([r, blank].join('\\n'))\n      }\n      return [header, blank, ...rows, header, blank, footer].join('\\n')\n    }\n\n    clear(): void {\n      this.reset(Game.emptyFen)\n    }\n\n    fen(index: number = this.getMaxPos()): string {return this.fens[index]}\n\n    history(options: object = {verbose: false}): any[] {\n        if (options['verbose']) {\n            return this.sans.slice(1)\n        } else {\n            return this.sans.slice(1).map( mi => mi.san)\n        }\n    }\n\n    game_over(): boolean {\n      //Must override\n      return false\n    }\n\n    get(square: any, index: number = this.getMaxPos()): string {\n      if (typeof square === 'string') square = Game.san2sq(square)\n      return this.getPos(index)[square]\n    }\n\n    in_check(index: number = this.getMaxPos()): boolean {\n      //Must override\n      if (index < 0 || index > this.getMaxPos()) return false\n      return false\n    }\n\n    in_checkmate(index: number = this.getMaxPos()): boolean {\n      //Must override\n      if (index < 0 || index > this.getMaxPos()) return false\n      return false\n    }\n\n    in_draw(index: number = this.getMaxPos()): boolean {\n      //Must override\n      if (index < 0 || index > this.getMaxPos()) return false\n      return false\n    }\n\n    in_stalemate(index: number = this.getMaxPos()): boolean {\n      //Must override\n      if (index < 0 || index > this.getMaxPos()) return false\n      return false\n    }\n\n    in_threefold_repetition(index: number = this.getMaxPos()): boolean {\n      if (index < 0 || index > this.getMaxPos()) return false\n        let sliced: string[] = this.fens.map(fen => fen.split(/\\s+/).slice(0, 4).join(' '))\n        // console.log(sliced)\n        for (let i = 0; i <= index; i++ ) {\n          let reps = 1\n          for (let j = i + 1; j <= index; j++) {\n            if (sliced[i] === sliced[j]) {\n              reps++\n              console.log(`Position ${sliced[j]} has repeated ${reps} times`)\n              if (reps >= 3) {\n                return true\n              }\n            }\n          }\n        }\n      return false\n    }\n\n    header(...args: string[]): ISevenTags {\n      if (Game.isOdd(args.length)) args = args.slice(0, args.length - 1)\n      if (!args.length) return this.tags\n      let [keys, values] = [args.filter((_, i) => Game.isEven(i)).map(Game.capitalize),\n        args.filter((_, i) => Game.isOdd(i))]\n      for (let n: number = 0; n < keys.length; n++) {\n        this.tags[keys[n]] = values[n]\n      }\n      return this.tags\n    }\n\n    insufficient_material(_: number = this.getMaxPos()): boolean\n    {\n      //Must override\n      return false\n    }\n\n    label(): string  {return `${this.tags.White} - ${this.tags.Black}\\t ${this.tags.Result}`}\n\n    toString(): string {return this.label()}\n    \n    load(fen: string = Game.defaultFen): boolean {\n      this.reset(fen)\n      return true\n    }\n\n    load_pgn(pgn: string): boolean {\n      if (!pgn.length) return false\n      //Must override\n      return false\n    }\n\n      \n\n    move(...args: any[]): boolean {\n        let moveInfo: IMoveInfo\n        let from: any\n        let to: any\n        let promotion: string\n\n        if (args.length === 0) {\n          return false\n        } else if (args.length === 1) {\n          if (typeof args[0] === 'string') {\n            moveInfo = this.san2MoveInfo(args[0])\n            if (!moveInfo) return false \n            from = moveInfo.from\n            to = moveInfo.to\n            promotion = moveInfo.promotion\n          } else {\n            return false\n          }\n        } else {\n            [from, to, promotion] = args\n            if (typeof from === 'string') {\n              from = Game.san2sq(from)\n            }  \n    \n            if (typeof to === 'string') {\n              to = Game.san2sq(to)\n            }  \n        }\n\n        let fObj: IFenObj = Game.fen2obj(this.fens[this.getMaxPos()])\n        let pos: string[] = fObj.pos.split('')\n        let turn: string = fObj.turn\n        let figFrom: string = pos[from]\n        let figInTo: string = pos[to]\n        let figTo: string = promotion ? promotion : figFrom\n\n        moveInfo = <IMoveInfo>{enPassant: false}\n\n        moveInfo.turn = turn\n        moveInfo.from = from\n        moveInfo.to = to\n        moveInfo.figureFrom = figFrom\n        moveInfo.figureTo = figInTo\n        moveInfo.promotion = promotion\n        moveInfo.capture = figInTo !== '0' || (this.isEnPassant(from, to) \n          && to === Game.san2sq(fObj.enPassant))\n        moveInfo.san = this.moveInfo2san(moveInfo)\n        moveInfo.fullMoveNumber = fObj.fullMoveNumber\n        moveInfo.castling = this.isShortCastling(from, to, moveInfo.figureFrom) \n          || this.isLongCastling(from, to, moveInfo.figureFrom)\n\n        let bCan = this.canMove(moveInfo)\n\n        if (!bCan) return false\n\n        pos[from] = '0'\n        pos[to] = figTo\n        if (figFrom === 'K' && from === 4 && to === 6) {\n            pos[7] = '0'\n            pos[5] = 'R'\n        }\n        if (figFrom === 'K' && from === 4 && to === 2) {\n            pos[0] = '0'\n            pos[3] = 'R'\n        }\n        if (figFrom === 'k' && from === 60 && to === 62) {\n            pos[63] = '0'\n            pos[61] = 'r'\n        }\n        if (figFrom === 'k' && from === 60 && to === 58) {\n            pos[56] = '0'\n            pos[59] = 'R'\n        }\n\n        if (this.isEnPassant(from, to)) {\n            //console.log(\"En passant move from \" + from + \" to \" + to)\n            if (to !== Game.san2sq(fObj.enPassant)) {\n                //console.log(`Destination is ${to} and en-passant is ${Game.san2sq(fObj.enPassant)}`)\n            } else {\n                let sunk: number = Game.san2sq(fObj.enPassant) + 8 * (figFrom === 'P' ? -1 : 1)\n                //console.log(\"En passant sunk pawn at \" + sunk) \n                pos[sunk] = '0'\n                moveInfo.enPassant = true\n            }\n        }\n\n        switch(from) {\n            case 4:\n            fObj.castling = fObj.castling.replace(/[KQ]/g, '')\n            break\n            case 60:\n            fObj.castling = fObj.castling.replace(/[kq]/g, '')\n            break\n            case 0:\n            fObj.castling = fObj.castling.replace('Q', '')\n            break\n            case 7:\n            fObj.castling = fObj.castling.replace('K', '')\n            break\n            case 56:\n            fObj.castling = fObj.castling.replace('q', '')\n            break\n            case 63:\n            fObj.castling = fObj.castling.replace('k', '')\n            break\n            default:\n        }\n        fObj.castling = fObj.castling === '' ? '-' : fObj.castling\n\n        if (this.isTwoSteps(from, to)) {\n            fObj.enPassant = Game.sq2san(figFrom === 'P' ? to - 8 : to + 8)\n        } else {\n            fObj.enPassant = '-'\n        }\n\n        fObj.halfMoveClock = !!figFrom.match(/[Pp]/) || moveInfo.capture ? 0 : ++fObj.halfMoveClock\n        fObj.fullMoveNumber = turn === 'w' ? fObj.fullMoveNumber : ++ fObj.fullMoveNumber\n        \n        fObj = {\n            ...fObj, \n            pos: pos.join(''), \n            fenPos: Game.compressFenPos(pos.join('')),\n            turn: turn === 'w' ? 'b' : 'w'\n            }\n        this.fens = [...this.fens, Game.obj2fen(fObj)]\n        this.sans = [...this.sans, moveInfo]\n        return true\n    }\n\n    moves(options: object = null): string[] {\n      //Must override\n      if (!!options) {\n        return []\n      } else {\n        return []\n      }\n    } \n\n    pgn(): string {\n      return `${[this.pgnHeaders(), this.pgnMoves()].join('\\n\\n')} ${this.tags.Result}`\n    }\n\n    put(figure: string, square: any, index: number = this.getMaxPos()): boolean {\n      if (\"pnbrqk0\".indexOf(figure.toLowerCase()) === -1) return false\n      if (typeof square === 'string') square = Game.san2sq(square)\n      if (square < 0 || square > 63) return false\n      let fen_obj: IFenObj = Game.fen2obj(this.fens[index])\n      let posArray: string[] = fen_obj.pos.split('')\n      posArray[square] = figure\n      delete(fen_obj.fenPos)\n      fen_obj.pos = posArray.join('')\n      let fen: string = Game.obj2fen(fen_obj)\n      this.fens[index] = fen\n      return true\n    }\n\n    remove(square: any, index: number = this.getMaxPos()): boolean {\n      return this.put('0', square, index)\n    }\n\n    square_color(square: any): string {\n      if (typeof square === 'string') square = Game.san2sq(square)\n      return Game.isDark(square) ? 'dark' : 'light'\n    }\n\n    turn(index: number = this.getMaxPos()): string {\n      return this.getTurn(index)\n    }\n\n    undo(): boolean {\n      if (this.getMaxPos() < 1) return false\n      this.fens.pop()\n      this.sans.pop()\n      this.tags.Result = Game.results.unterminated\n      return true\n    }\n\n    validate_fen(fen: string): boolean {\n      //Must override\n      if (fen.length) return true\n      return false\n    }    \n\n  }\n  \n \n","\nimport { Game, IMoveInfo, IFenObj } from './game'\n\nexport interface IFenMoveInfo {\n    moveInfo: IMoveInfo\n    fen: string\n}\n\nexport enum PgnState {\n\tSCANNING = 0,\n\tLABEL = 1,\n\tVALUE = 2,\n\tTOKEN = 3,\n\tCOMMENT = 4,\n\tVARIANT = 5\n}\n\n\nexport class Chess extends Game {\n\n    static difCol(sq1: number, sq2: number): number {\n        return Math.abs(Game.col(sq1) - Game.col(sq2))\n    }\n\n    static difRow(sq1: number, sq2: number): number {\n        return Math.abs(Game.row(sq1) - Game.row(sq2))\n    }\n\n    static isSameCol(sq1: number, sq2: number): boolean {\n        return Chess.difCol(sq1, sq2) === 0\n    }\n\n    static isSameRow(sq1: number, sq2: number): boolean {\n        return Chess.difRow(sq1, sq2) === 0\n    }\n\n    static isDiagonal(sq1: number, sq2: number): boolean {\n        return Chess.difRow(sq1, sq2) === Chess.difCol(sq1, sq2) \n    }\n\n    static isAntiDiagonal(sq1: number, sq2: number): boolean {\n        return Chess.isDiagonal(sq1, sq2) && Math.abs(sq1 - sq2) % 7 == 0 && sq1 !== 63 && sq2 !== 63\n    }\n\n    static isAdjacent(sq1: number, sq2: number): boolean {\n        return Chess.difCol(sq1, sq2) < 2 && Chess.difRow(sq1, sq2) < 2\n    }\n\n    static isKingAttack(sq1: number, sq2: number): boolean {\n        return (sq1 !== sq2) && Chess.isAdjacent(sq1, sq2)     \n    }\n\n    static isWKingCastling(from: number, to: number): boolean {\n        return from === 4 && (to === 6 || to === 2)\n    }\n\n    static isBKingCastling(from: number, to: number): boolean {\n        return from === 60 && (to === 62 || to === 58)\n    }\n\n    static isWPawnAttack(from: number, to: number): boolean {\n        return (Chess.row(to) === (Chess.row(from) + 1)) && (Chess.difCol(from, to) === 1)\n    }\n\n    static isBPawnAttack(from: number, to: number): boolean {\n        return (Chess.row(to) === (Chess.row(from) - 1)) && (Chess.difCol(from, to) === 1)\n    }\n\n    static isWPawnMove(from: number, to: number): boolean {\n        const rowFrom = Game.row(from)\n        if (rowFrom === 1) {\n            return ((Chess.row(to) === rowFrom + 1) || (Chess.row(to) === rowFrom + 2)) \n              && Chess.isSameCol(from, to)\n        } else {\n            return (Chess.row(to) === rowFrom + 1) && Chess.isSameCol(from, to)\n        }\n    }\n\n    static isBPawnMove(from: number, to: number): boolean {\n        const rowFrom = Game.row(from)\n        if (rowFrom === 6) {\n            return ((Chess.row(to) === rowFrom - 1) || (Chess.row(to) === rowFrom - 2)) \n              && Chess.isSameCol(from, to)\n        } else {\n            return (Chess.row(to) === rowFrom - 1) && Chess.isSameCol(from, to)\n        }\n    }\n\n    static isKnightAttack(sq1: number, sq2: number): boolean {\n        return (Chess.difRow(sq1, sq2) === 2 && Chess.difCol(sq1, sq2) === 1)\n          || (Chess.difRow(sq1, sq2) === 1 && Chess.difCol(sq1, sq2) === 2) \n    }\n\n    static isBishopAttack(sq1: number, sq2: number): boolean {\n        return (sq1 !== sq2) && Chess.isDiagonal(sq1, sq2)     \n    }\n\n    static isRookAttack(sq1: number, sq2: number): boolean {\n        return (sq1 !== sq2) && (Chess.isSameRow(sq1, sq2) || Chess.isSameCol(sq1, sq2))\n    }\n\n    static isQueenAttack(sq1: number,sq2: number): boolean {\n        return Chess.isRookAttack(sq1, sq2) || Chess.isBishopAttack(sq1, sq2)\n    }\n\n    static path(sq1: number, sq2: number): number[] {\n        if (!Chess.isQueenAttack(sq1, sq2) && !Chess.isKnightAttack(sq1, sq2)) return []\n        if (Chess.isKnightAttack(sq1, sq2)) return [sq1, sq2]\n        let result: number[] = []\n        let sqOrig: number = sq1 <= sq2 ? sq1 : sq2\n        let sqDest: number = sq2 >= sq1 ? sq2 : sq1\n        let step: number = Chess.isAntiDiagonal(sqOrig, sqDest) ? 7 :\n                           Chess.isDiagonal(sqOrig, sqDest) ? 9 :\n                           Chess.isSameCol(sqOrig, sqDest) ? 8 : 1\n        for (let n: number = sqOrig; n <= sqDest; n += step) {\n            result = [...result, n]\n        }\n        return result\n    }\n\n    static innerPath(sq1: number, sq2: number): number[] {\n        const p: number[] = Chess.path(sq1, sq2)\n        return p.slice(1, p.length - 1)\n    }\n\n    static isClearPath (sq1: number, sq2: number, fen: string): boolean {\n      const inner: number[] = Chess.innerPath(sq1, sq2)\n      if (inner.length === 0) return true\n      const fenObj: IFenObj = Game.fen2obj(fen)\n      for (let i:number = 0; i < inner.length; i++) {\n            if (fenObj.pos[inner[i]] !== '0') return false \n        } \n        return true\n    }\n       \n    static inScope(from: number, to: number, fen: string, onlyAttacks: boolean = false): boolean {\n        const fenObj: IFenObj = Game.fen2obj(fen)\n        const figure: string = fenObj.pos[from]\n\n        switch (figure) {\n           case 'p':\n             if (onlyAttacks) {\n               return Chess.isBPawnAttack(from, to)\n             } else {\n                 return Chess.isBPawnAttack(from, to) || Chess.isBPawnMove(from, to)\n             }\n           case 'P':\n             if (onlyAttacks) {\n               return Chess.isWPawnAttack(from, to)\n             } else {\n                 return Chess.isWPawnAttack(from, to) || Chess.isWPawnMove(from, to)\n             }\n           case 'n':\n           case 'N':\n             return Chess.isKnightAttack(from, to) \n           case 'b':\n           case 'B':\n             return Chess.isBishopAttack(from, to)\n           case 'r':\n           case 'R':\n             return Chess.isRookAttack(from, to) \n           case 'q':\n           case 'Q':\n             return Chess.isQueenAttack(from, to)\n           case 'k':\n             if (onlyAttacks) {\n               return Chess.isKingAttack(from, to)\n             } else {\n                 return Chess.isKingAttack(from, to) || Chess.isBKingCastling(from, to)\n             }\n           case 'K':\n             if (onlyAttacks) {\n               return Chess.isKingAttack(from, to)\n             } else {\n                 return Chess.isKingAttack(from, to) || Chess.isWKingCastling(from, to)\n             }\n           default:\n             return false      \n        }\n    }\n\n    static army(color: string, fen: string): number[] {\n        const army_string: string = color === 'b' ? 'pnbrqk' : 'PNBRQK'\n        const position: string = Game.fen2obj(fen).pos\n        const indexes = position.split('').map((_, i) => i)\n        return indexes.filter((i => army_string.includes(position[i])))\n    }\n\n    static attacksOnSquare(color: string, fen: string, square: number): number [] {\n        const position: string = Game.fen2obj(fen).pos\n        const attackers: number[] = Chess.army(color, fen)\n        return attackers.filter(i => Chess.canAttack(i, square, fen))\n    }\n\n    static canReach(from: number, to: number, fen: string): boolean {\n      return Chess.inScope(from, to, fen) && Chess.isClearPath(from, to, fen)\n    }\n\n    static canAttack(from: number, to: number, fen: string): boolean {\n        return Chess.inScope(from, to, fen, true) && Chess.isClearPath(from, to, fen)\n    }\n\n    static kingSquare(color: string, fen: string): number {\n        const king = color === 'w' ? 'K' : 'k'\n        const fenObj = Game.fen2obj(fen)\n        for (let i: number = 0; i < 64; i++) {\n            if (fenObj.pos[i] === king) return i\n        }\n        return -1\n    }\n\n    static checks (color: string, fen: string): number {\n        let jaques: number = 0\n        const attackers: string = color === 'w' ? 'b' : 'w'\n        const kingSq: number = Chess.kingSquare(color, fen)\n        return Chess.attacksOnSquare(attackers, fen, kingSq).length\n    }\n\n    static sideCanWin(side: string, fen: string): boolean {\n        if (!\"wb\".includes(side) || side.length !== 1) return false\n        const pos: string[] = Game.fen2obj(fen).pos.split('')\n        let [p, n, b, r, q] = side === 'b' ? ['p', 'n', 'b', 'r', 'q'] : ['P', 'N', 'B', 'R', 'Q']\n        let [fp, fn, fb, fr, fq] = side === 'w' ? ['p', 'n', 'b', 'r', 'q'] : ['P', 'N', 'B', 'R', 'Q']\n        let [pc, nc, bc, rc, qc] = [\n          Game.countFigures(p, fen),\n          Game.countFigures(n, fen),\n          Game.countFigures(b, fen),\n          Game.countFigures(r, fen),\n          Game.countFigures(q, fen)\n        ]\n        let [fpc, fnc, fbc, frc, fqc] = [\n          Game.countFigures(fp, fen),\n          Game.countFigures(fn, fen),\n          Game.countFigures(fb, fen),\n          Game.countFigures(fr, fen),\n          Game.countFigures(fq, fen)\n        ]\n  \n        // console.log(pc, nc, bc, rc, qc, \" - \", fpc, fnc, fbc, frc, fqc)\n  \n        if (pc || rc || qc) return true\n  \n        if (nc && bc) return true\n  \n        switch (nc) {\n          case 0:\n            if (!bc) return false\n            break\n          case 1:\n            if (fpc || fnc || fbc || frc) {\n              return true\n            } else {\n              return false\n            }\n          case 2:\n            if (fpc || fnc || fbc || frc || fqc) {\n              return true\n            } else {\n              return false\n            }\n          default:\n            return true\n        }\n  \n        switch (bc) {\n          case 0:\n            return false\n          case 1:\n            if (fpc || fnc) {\n              return true\n            } else if (fbc) {\n                let bcolors: string[] = Game.figuresColors(b, fen)\n                let fbcolors: string[] = Game.figuresColors(fb, fen)\n                for (let i: number = 0; i < fbcolors.length; i++) {\n                    if (bcolors[0] !== fbcolors[i]) return true\n                }\n                return false\n            } else {\n              return false\n            }\n          default:\n            let bcolors: string[] = Game.figuresColors(b, fen)\n            for (let i: number = 1; i < bcolors.length; i++) {\n                if (bcolors[0] !== bcolors[i]) return true\n            }\n            if (fpc || fnc) {\n                return true\n              } else if (fbc) {\n                  let fbcolors: string[] = Game.figuresColors(fb, fen)\n                  for (let i: number = 0; i < fbcolors.length; i++) {\n                      if (bcolors[0] !== fbcolors[i]) return true\n                  }\n                  return false\n              } else {\n                return false\n            }\n  \n        }\n  \n        return false\n      }  \n\n    static lex_pgnfile(pgnFileStr: string): string[] {\n        pgnFileStr = pgnFileStr.replace(/\\r/g, '\\n')\n        let pgnFragments: string[] = pgnFileStr.split(/\\n{2,}/)\n        if (Game.isOdd(pgnFragments.length)) pgnFragments = pgnFragments.slice(0, pgnFragments.length - 1)\n        if (!pgnFragments.length) return [\"\"]\n        let pgns: string[] = []\n        for (let n: number = 0; n < pgnFragments.length; n += 2) {\n            pgns = [...pgns, [pgnFragments[n], pgnFragments[n + 1]].join('\\n\\n')]\n        }\n        return pgns\n    }\n     \n    static parse_pgnfile(pgnFileStr: string): Chess[] {\n        const pgns: string[] = Chess.lex_pgnfile(pgnFileStr)\n        if (!pgns.length) return []\n        let games: Chess[] = []\n        for (let n: number = 0; n < pgns.length; n++) {\n            let game = new Chess()\n            if (game.load_pgn(pgns[n])) games = [...games, game]\n        }\n        return games\n    }\n\n    san2MoveInfo(san: string, fen: string = this.fen()): IMoveInfo {\n        // overriden\n        //const sanRegExp = /(?:(^0-0-0|^O-O-O)|(^0-0|^O-O)|(?:^([a-h])(?:([1-8])|(?:x([a-h][1-8])))(?:=?([NBRQ]))?)|(?:^([NBRQK])([a-h])?([1-8])?(x)?([a-h][1-8])))(?:(\\+)|(#)|(\\+\\+))?$/\n\n        if (!san.length) return <IMoveInfo>null\n        const match = san.match(Game.sanRegExp)\n        if (!match) return  <IMoveInfo>null\n        const [_, longC, shortC, \n               pawnCol, pawnDestRow, pawnCaptureDest, promotion,\n               figure, origCol, origRow, captureToken, figureDest, \n               check, ckeckMate, altCheckMate] = match\n        const fen_obj = Game.fen2obj(fen)       \n        let retInfo = <IMoveInfo>{}\n        retInfo.turn = fen_obj.turn\n        retInfo.fullMoveNumber = fen_obj.fullMoveNumber\n        \n\n        if (longC) {\n            retInfo.figureFrom = retInfo.turn === 'b' ? 'k' : 'K'\n            retInfo.figureTo = '0'\n            retInfo.from = retInfo.turn === 'b' ? 60 : 4\n            retInfo.to = retInfo.turn === 'b' ? 58 : 2\n            retInfo.san = 'O-O-O'\n            retInfo.castling = true\n            return retInfo\n        } \n        if (shortC) {\n            retInfo.figureFrom = retInfo.turn === 'b' ? 'k' : 'K'\n            retInfo.figureTo = '0'\n            retInfo.from = retInfo.turn === 'b' ? 60 : 4\n            retInfo.to = retInfo.turn === 'b' ? 62 : 6\n            retInfo.san = 'O-O'\n            retInfo.castling = true\n            return retInfo\n        }\n\n        if (pawnCol) {\n         retInfo.figureFrom = retInfo.turn === 'b' ? 'p' : 'P'\n         let origCol: number = Game.string2col(pawnCol)\n         let origRow: number\n         let destCol: number\n         let destRow: number  \n         if (pawnDestRow) {\n            retInfo.figureTo = '0'\n            destRow = Game.string2row(pawnDestRow)\n            destCol = origCol\n            origRow = retInfo.turn === 'b' ? destRow + 1 : destRow - 1\n            retInfo.from = Game.rowcol2sq(origRow, origCol)\n            if (!fen_obj.pos[retInfo.from].match(/[Pp]/)) {\n                retInfo.from += retInfo.turn === 'b' ? 8 : -8\n            }\n            if (!fen_obj.pos[retInfo.from].match(/[Pp]/)) {\n                return <IMoveInfo>null\n            }\n            retInfo.to = Game.rowcol2sq(destRow, destCol)\n         } else if (pawnCaptureDest) {\n            retInfo.capture = true\n            retInfo.to = Game.san2sq(pawnCaptureDest)\n            retInfo.figureTo = fen_obj.pos[retInfo.to]\n            origRow = Game.row(retInfo.to) + ((retInfo.turn === 'w') ? -1 : 1)\n            retInfo.from = Game.rowcol2sq(origRow, origCol) \n            //console.log(origRow)\n            //console.log(retInfo)\n         }\n         if (promotion) {\n             retInfo.promotion = retInfo.turn === 'b' \n               ? promotion.toLowerCase()\n               : promotion.toUpperCase()\n         }\n         return retInfo\n        } else if (figure) {\n          let figurine: string = retInfo.turn === 'w' ? figure.toUpperCase() : figure.toLowerCase()\n          //console.log(`Figurine: ${figurine}`)\n          retInfo.figureFrom = figurine\n          retInfo.from = -1\n          retInfo.to = Game.san2sq(figureDest)\n          retInfo.figureTo = fen_obj.pos[retInfo.to]\n          retInfo.capture = retInfo.figureTo !== '0'\n        //   const candidates: IMoveInfo[] = this.moves({verbose: true})\n        //   .filter((mi: IMoveInfo) => {\n        //     return mi.figureFrom === figurine && mi.to === retInfo.to \n        //   })\n          const candidates: number[] = Game.boardArray().filter(i => fen_obj.pos[i] === figurine)\n          .filter(i => Chess.canReach(i, retInfo.to, fen))\n          .filter(i => {\n              const info: IFenMoveInfo = this.tryMove(i, retInfo.to)\n              return info && this.validate_fen(info.fen) \n          })\n          //console.log(`Candidates: ${candidates}`)\n          switch (candidates.length) {\n              case 0:\n                return <IMoveInfo>null\n              case 1:\n                retInfo.from = candidates[0]\n                break\n              default:\n                if (origCol && origRow) {\n                    let from: number = Game.san2sq(`${origCol}${origRow}`)\n                    for (let n: number = 0; n < candidates.length; n++) {\n                        if (candidates[n] === from) {\n                            retInfo.from = from\n                            break\n                        }\n                    }\n                } else if (origCol) {\n                    let col = Game.string2col(origCol)\n                    for (let n: number = 0; n < candidates.length; n++) {\n                        if (Game.col(candidates[n]) === col) {\n                            retInfo.from = candidates[n]\n                            break\n                        }\n                    }\n                } else if (origRow) {\n                    let row = Game.string2row(origRow)\n                    for (let n: number = 0; n < candidates.length; n++) {\n                        if (Game.row(candidates[n]) === row) {\n                            retInfo.from = candidates[n]\n                            break\n                        }\n                    }\n                } else {\n                    return <IMoveInfo>null\n                }\n          }\n          return retInfo.from !== -1 ? retInfo : <IMoveInfo>null  \n        } else {\n            return <IMoveInfo>null\n        }\n\n    }\n  \n    canMove(moveInfo: IMoveInfo, n: number = this.getMaxPos()): boolean {\n        //Overriden version\n\n        const parentResult = super.canMove(moveInfo, n)\n        if (!parentResult) return false\n        //super.canMove() tests: \n        // 1) that the original figure is a valid one\n        // 2) that the turn is correct\n        // 3) that it's not \"friendly fire\", i.e. not moving over a friend figure.\n\n        const result = Chess.canReach(moveInfo.from, moveInfo.to, this.fens[n])\n        if (!result) return false\n        \n        //Todo: consider constraints for pawn actions and castling before returning true\n\n        //King castling constraints\n        if (moveInfo.figureFrom === 'K' && moveInfo.from === 4 && moveInfo.to === 6) {\n            if (!this.getCastling(n).includes('K')) return false\n            if (moveInfo.figureTo !== '0') return false\n            if (Chess.attacksOnSquare('b', this.fens[n], 4).length) return false \n            if (Chess.attacksOnSquare('b', this.fens[n], 5).length) return false \n        }\n        if (moveInfo.figureFrom === 'K' && moveInfo.from === 4 && moveInfo.to === 2) {\n            if (!this.getCastling(n).includes('Q')) return false\n            if (moveInfo.figureTo !== '0') return false\n            if (Chess.attacksOnSquare('b', this.fens[n], 4).length) return false \n            if (Chess.attacksOnSquare('b', this.fens[n], 3).length) return false \n        }\n        if (moveInfo.figureFrom === 'k' && moveInfo.from === 60 && moveInfo.to === 62) {\n            if (!this.getCastling(n).includes('k')) return false\n            if (moveInfo.figureTo !== '0') return false\n            if (Chess.attacksOnSquare('w', this.fens[n], 60).length) return false \n            if (Chess.attacksOnSquare('w', this.fens[n], 61).length) return false \n            }\n            if (moveInfo.figureFrom === 'k' && moveInfo.from === 60 && moveInfo.to === 58) {\n                if (!this.getCastling(n).includes('q')) return false\n                if (moveInfo.figureTo !== '0') return false\n                if (Chess.attacksOnSquare('w', this.fens[n], 60).length) return false \n                if (Chess.attacksOnSquare('w', this.fens[n], 59).length) return false \n            }\n\n        //Consider pawn move constraints\n        const isFoe: boolean = moveInfo.to === Game.san2sq(this.getEnPassant(n)) \n            || Game.isFoe(moveInfo.figureFrom, moveInfo.figureTo)\n        if (moveInfo.figureFrom === 'P') {\n            if (Chess.isWPawnMove(moveInfo.from, moveInfo.to) && moveInfo.figureTo !== '0') return false\n            if (Chess.isWPawnAttack(moveInfo.from, moveInfo.to) && !isFoe) return false\n        }\n        if (moveInfo.figureFrom === 'p') {\n            if (Chess.isBPawnMove(moveInfo.from, moveInfo.to) && moveInfo.figureTo !== '0') return false\n            if (Chess.isBPawnAttack(moveInfo.from, moveInfo.to) && !isFoe) return false\n        }\n            \n        return true\n    }\n\n    tryMove(from: any, to: any, promotion: string = <string>null): IFenMoveInfo {\n\n        let moveInfo: IMoveInfo\n        \n        if (typeof from === 'string') {\n          from = Game.san2sq(from)\n        }  \n    \n        if (typeof to === 'string') {\n          to = Game.san2sq(to)\n        }  \n\n        if (Game.outOfBounds(from, to)) return <IFenMoveInfo>null\n\n        let fObj: IFenObj = Game.fen2obj(this.fens[this.getMaxPos()])\n        let pos: string[] = fObj.pos.split('')\n        let turn: string = fObj.turn\n        let figFrom: string = pos[from]\n        let figInTo: string = pos[to]\n        let figTo: string = promotion ? promotion : figFrom\n\n        moveInfo = <IMoveInfo>{enPassant: false}\n\n        moveInfo.turn = turn\n        moveInfo.from = from\n        moveInfo.to = to\n        moveInfo.figureFrom = figFrom\n        moveInfo.figureTo = figInTo\n        moveInfo.promotion = promotion\n        moveInfo.capture = figInTo !== '0' || (this.isEnPassant(from, to) \n          && to === Game.san2sq(fObj.enPassant))\n        //console.log(`moveInfo.figureFrom = ${moveInfo.figureFrom}`)  \n        moveInfo.san = this.moveInfo2san(moveInfo)\n        moveInfo.fullMoveNumber = fObj.fullMoveNumber\n        moveInfo.castling = this.isShortCastling(from, to, moveInfo.figureFrom) || this.isLongCastling(from, to, moveInfo.figureFrom)\n\n        let bCan = this.canMove(moveInfo)\n\n        if (!bCan) return <IFenMoveInfo>null\n\n        pos[from] = '0'\n        pos[to] = figTo\n        if (figFrom === 'K' && from === 4 && to === 6) {\n            pos[7] = '0'\n            pos[5] = 'R'\n            moveInfo.san = 'O-O'\n        }\n        if (figFrom === 'K' && from === 4 && to === 2) {\n            pos[0] = '0'\n            pos[3] = 'R'\n            moveInfo.san = 'O-O-O'\n        }\n        if (figFrom === 'k' && from === 60 && to === 62) {\n            pos[63] = '0'\n            pos[61] = 'r'\n            moveInfo.san = 'O-O'\n        }\n        if (figFrom === 'k' && from === 60 && to === 58) {\n            pos[56] = '0'\n            pos[59] = 'R'\n            moveInfo.san = 'O-O-O'\n        }\n\n        if (this.isEnPassant(from, to)) {\n            ////console.log(\"En passant move from \" + from + \" to \" + to)\n            if (to !== Game.san2sq(fObj.enPassant)) {\n                ////console.log(`Destination is ${to} and en-passant is ${Game.san2sq(fObj.enPassant)}`)\n            } else {\n                let sunk: number = Game.san2sq(fObj.enPassant) + 8 * (figFrom === 'P' ? -1 : 1)\n                ////console.log(\"En passant sunk pawn at \" + sunk) \n                pos[sunk] = '0'\n                moveInfo.enPassant = true\n            }\n        }\n\n        switch(from) {\n            case 4:\n            fObj.castling = fObj.castling.replace(/[KQ]/g, '')\n            break\n            case 60:\n            fObj.castling = fObj.castling.replace(/[kq]/g, '')\n            break\n            case 0:\n            fObj.castling = fObj.castling.replace('Q', '')\n            break\n            case 7:\n            fObj.castling = fObj.castling.replace('K', '')\n            break\n            case 56:\n            fObj.castling = fObj.castling.replace('q', '')\n            break\n            case 63:\n            fObj.castling = fObj.castling.replace('k', '')\n            break\n            default:\n        }\n        fObj.castling = fObj.castling === '' ? '-' : fObj.castling\n\n        if (this.isTwoSteps(from, to)) {\n            fObj.enPassant = Game.sq2san(figFrom === 'P' ? to - 8 : to + 8)\n        } else {\n            fObj.enPassant = '-'\n        }\n\n        fObj.halfMoveClock = !!figFrom.match(/[Pp]/) || moveInfo.capture ? 0 : ++fObj.halfMoveClock\n        fObj.fullMoveNumber = turn === 'w' ? fObj.fullMoveNumber : ++ fObj.fullMoveNumber\n        \n        fObj = {\n            ...fObj, \n            pos: pos.join(''), \n            fenPos: Game.compressFenPos(pos.join('')),\n            turn: turn === 'w' ? 'b' : 'w'\n        }\n        return {fen: Game.obj2fen(fObj), moveInfo: moveInfo}\n    }\n\n    game_over(): boolean {\n    //Overriden\n    return this.in_checkmate() \n        || this.in_stalemate()\n        || this.in_draw()\n        || this.in_threefold_repetition() \n        || this.insufficient_material()\n    }\n\n\n    in_check(index: number = this.getMaxPos()): boolean {\n    if (index < 0 || index > this.getMaxPos()) return false\n    return Chess.checks(this.getTurn(index), this.fen(index)) > 0\n    }\n\n    in_checkmate(index: number = this.getMaxPos()): boolean {\n    //Overriden\n    if (index < 0 || index > this.getMaxPos()) return false\n    return this.in_check(index) && this.moves(null, index).length === 0\n    }\n\n    in_draw(index: number = this.getMaxPos()): boolean {\n    //Overriden\n        return this.insufficient_material(index) || Game.fen2obj(this.fen(index)).halfMoveClock >= 100\n    }\n\n    in_stalemate(index: number = this.getMaxPos()): boolean {\n    //Overriden\n      return !this.in_check(index) && this.moves(null, index).length === 0\n    }\n\n    insufficient_material(index: number = this.getMaxPos()): boolean\n    {\n    //Overriden\n      return (!Chess.sideCanWin('w', this.fen(index)) && !Chess.sideCanWin('b', this.fen(index)))\n    }\n\n\n\tload_pgn(pgn: string): boolean {\n            let current: string = ''\n            let token_str: string = \"\"\n            let label_str: string = \"\"\n            let value_str: string = \"\"\n            let index: number = 0\n            let state: PgnState = PgnState.SCANNING\n            let prev_state: PgnState = PgnState.SCANNING\n\n            let game: Chess = new Chess()\n            \n            let strip_nums = (text: string): string => text.replace(/\\d+\\.\\s*(\\.\\.\\.)?\\s*/g, '')\n\n            let is_san = (text: string): boolean => !!text.match(Game.sanRegExp)\n\n            let is_result = (text: string): boolean => {\n                for (let n in Game.results) {\n                    if (text === Game.results[n]) return true\n                }\n                return false\n            }\n\n            do {\n                current = pgn[index++];\n        \n                switch (state) {\n                    case PgnState.SCANNING:\n                    if ('[' === current) {\n                        state = PgnState.LABEL\n                        continue\t\n                    } else if ('{' === current) {\n                        prev_state = state\n                        state = PgnState.COMMENT\n                        continue\n                    } else if ('(' === current) {\n                        prev_state = state\n                        state = PgnState.VARIANT\n                        continue\n                    } else if (current.match(/[\\s\\]]/)) {\n                        continue\n                    } else {\n                        state = PgnState.TOKEN\n                        token_str = current\n                        continue\n                    }\n\n                    case 1: //PgnState.LABEL:\n                    if ('\"' === current) {\n                        state = PgnState.VALUE\n                    } else {\n                        label_str += current\n                    }\n                    continue\n\n                    case 2: //PgnState.VALUE:\n                    if ('\"' === current) {\n                        state = PgnState.SCANNING\n                        game.header(label_str.trim(), value_str)\n                        label_str = \"\"\n                        value_str = \"\"\n                    } else {\n                        value_str += current\n                    }\n                    continue \n                    case 3: //PgnState.TOKEN:\n                        if ('{' == current) {\n                            prev_state = state\n                            state = PgnState.COMMENT\n                        } else if ('(' == current) {\n                            prev_state = state\n                            state = PgnState.VARIANT\n                        } else if (current.match(/[\\s\\[]/)) {\n                            if (is_result(token_str)) game.header(\"Result\", token_str)\n                            if (is_result(token_str) || '[' === current) {\n                                this.fens = game.fens\n                                this.sans = game.sans\n                                this.tags = game.tags\n                                return true\t\t\n                            }\n                            let stripped: string = strip_nums(token_str)\n                            if (is_san(stripped)) {\n                                let bmove = game.move(stripped)\n                                if (!bmove) return false\n                            }\n                            token_str = \"\"\n                        } else {\n                            token_str += current\n                        }\n                    continue\n                    case PgnState.COMMENT:\n                    if ('}' == current) {\n                        state = prev_state\n                    }\n                    continue\n                    case PgnState.VARIANT:\n                    if (')' == current) {\n                        state = prev_state\n                    }\n                    continue\n                    default:\n                    continue\n                } \n            } while (index < pgn.length)\n            this.fens = game.fens\n            this.sans = game.sans\n            this.tags = game.tags\n            return true \t\t\n    }\n\n\n    getInfoOrigin(info: IMoveInfo, fen: string = this.fen()): string {\n        if (!!info.figureFrom.match(/[Pp]/)) return ''\n        const pos: string[] = Game.fen2obj(fen).pos.split('')\n        const army: number[] = pos.map((_, i) => i).filter((n) => n != info.from && pos[n] === info.figureFrom)\n        if (!army.length) return ''\n        const candidates: number[] = army.filter(n => Chess.canReach(n, info.to, fen))\n        if (!candidates.length) return ''\n        const alternatives: number[] = candidates.filter(n => {\n            const tuple: IFenMoveInfo = this.tryMove(n, info.to, info.promotion)\n            return !!tuple && this.validate_fen(tuple.fen)\n        })\n        //console.log(`alternatives[${info.figureFrom}]: ${alternatives}`)\n        switch (alternatives.length) {\n            case 0:\n              return ''\n            case 1:\n              if (Chess.isSameCol(info.from, alternatives[0])) {\n                  return Game.row2string(Game.row(info.from))\n              } else {\n                  return Game.col2string(Game.col(info.from))\n              }\n            default:\n              return Game.sq2san(info.from)\n        }\n    }\n\n    move(...args: any[]): boolean {\n\n        let from: any, to: any, promotion: string\n\n        switch (args.length) {\n          case 0:\n            return false\n          case 1: \n            let info: IMoveInfo = this.san2MoveInfo(args[0], this.fen())\n            if (!info) return false\n            from = info.from\n            to = info.to\n            promotion = info.promotion\n            break\n          default:\n            from = args[0]\n            to = args[1]\n            promotion = args[2]                     \n        }\n        if (typeof from === 'string') from = Game.san2sq(from)\n        if (typeof to === 'string') to = Game.san2sq(to)\n        if (Game.outOfBounds(from, to)) return false\n\n        //console.log(`from: ${from}, to: ${to}, promotion: ${promotion}`)\n        const tuple: IFenMoveInfo = this.tryMove(from, to, promotion)\n        if (tuple === null) return false\n        if (!this.validate_fen(tuple.fen)) return false\n \n        let infoOrigin: string = this.getInfoOrigin(tuple.moveInfo)\n        tuple.moveInfo = {...tuple.moveInfo, infoOrigin: infoOrigin}\n \n        this.fens = [...this.fens, tuple.fen]\n        if (this.in_checkmate()) {\n            tuple.moveInfo = {...tuple.moveInfo, checkmate: true}\n            this.tags.Result = tuple.moveInfo.turn === 'w' ? Game.results.white : Game.results.black\n        } else if (this.in_check()) {\n            tuple.moveInfo = {...tuple.moveInfo, check: true}\n        } else if (this.in_stalemate()) {\n            tuple.moveInfo = {...tuple.moveInfo, stalemate: true}\n            this.tags.Result = Game.results.draw\n        }\n        tuple.moveInfo = {...tuple.moveInfo, san: this.moveInfo2san(tuple.moveInfo)}\n        this.sans = [...this.sans, tuple.moveInfo]\n        return true\n    }\n\n    moves(options: object = null, index: number = this.getMaxPos()): any[] {\n        //Overriden\n        let result: IMoveInfo[] = []\n        const army: string = this.getTurn(index) === 'b' ? 'pnbrqk' : 'PNBRQK'\n        const fen: string = this.fens[index]\n        const position: string = Game.fen2obj(fen).pos\n\n        for (let from: number = 0; from < 64; from++) {\n            if (army.includes(position[from])) {\n                for (let to: number = 0; to < 64; to++) {\n                    let promotion: string = position[from] === 'P' && Game.row(to) === 7 \n                    ? 'Q'\n                    : position[from] === 'p' && Game.row(to) === 0\n                    ? 'q'\n                    : null\n                    let tuple: IFenMoveInfo = this.tryMove(from, to, promotion)\n                    if (tuple && this.validate_fen(tuple.fen)) {\n                        result = [...result, tuple.moveInfo]\n                        if (promotion) {\n                            let others: string[] = promotion === 'Q' ? ['N', 'R', 'B'] : ['n', 'r', 'b']\n                            others.forEach(figure => {\n                                result = [...result,\n                                          {...tuple.moveInfo, \n                                            promotion: figure, san: tuple.moveInfo.san.replace(promotion, figure)}]\n                            })\n                        }\n                    }\n                }\n            }\n        }\n\n        if (options && options['square']) {\n            let from: number = typeof options['square'] === 'string' \n              ? Game.san2sq(options['square']) \n              : options['square']\n            result = result.filter(mi => mi.from === from)\n        }\n        if (options && options['verbose']) {\n            return result\n        }  else {\n            return result.map(mi => mi.san)\n        }\n    }\n\n    validate_fen(fen: string): boolean {\n    //Check length of the string\n    if (!fen.length) return false\n    \n    //Check various anomalies\n    const fen_obj: IFenObj = Game.fen2obj(fen)\n    const pos: string[] = fen_obj.pos.split('')\n    let wKings: number = 0\n    let bKings: number = 0\n    let wPawns: number = 0\n    let bPawns: number = 0\n    let illegalFigs: number = 0\n\n    if (pos.length !== 64) return false\n    if (!fen_obj.turn.match(/[wb]/)) return false\n    if (!fen_obj.castling.match(/([KQkq]+)|(-)/)) return false\n    if (!fen_obj.enPassant.match(/([a-h](3|6))|(-)/)) return false\n\n    for (let n = 0; n < 64; n++) {\n        switch (pos[n]) {\n            case 'K':\n            wKings++\n            break\n            case 'k':\n            bKings++\n            break\n            case 'P':\n            wPawns++\n            break\n            case 'p':\n            bPawns++\n            break\n            default:\n            if (!\"NBRQnbrq0\".includes(pos[n])) illegalFigs++\n        }\n    }\n\n    if (wPawns > 8 || bPawns > 8 || wKings !== 1 || bKings !== 1 || illegalFigs > 0) return false\n    // //console.log(`wPawns: ${wPawns} - bPawns: ${bPawns} - wKings: ${wKings} - bKings: ${bKings}`)\n\n    //Check is not illegal according to checks\n    const turn: string = fen_obj.turn\n    const wChecks: number = Chess.checks('w', fen)\n    const bChecks: number = Chess.checks('b', fen)\n    if ((turn === 'w' && bChecks > 0) || (turn === 'b' && wChecks > 0)) return false\n\n    return true\n    }    \n      \n}\n\nif (typeof window !== 'undefined') window['Chess'] = Chess\n"]}